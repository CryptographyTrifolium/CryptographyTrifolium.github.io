[{"content":"梅森旋转生成随机数的逆向预测和恢复\r预测下一个随机数，恢复被隐藏的随机数据 首发于先知社区 ：子集和问题的两种解决方式-先知社区\n算法过程\rwiki上有算法实现的源代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def _int32(x): return int(0xFFFFFFFF \u0026amp; x) class MT19937: def __init__(self, seed): self.mt = [0] * 624 self.mt[0] = seed self.mti = 0 for i in range(1, 624): self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] \u0026gt;\u0026gt; 30) + i) def extract_number(self,x=None): if self.mti == 0 and x is None: self.twist() y = self.mt[self.mti] y = y ^ y \u0026gt;\u0026gt; 11 y = y ^ y \u0026lt;\u0026lt; 7 \u0026amp; 2636928640 y = y ^ y \u0026lt;\u0026lt; 15 \u0026amp; 4022730752 y = y ^ y \u0026gt;\u0026gt; 18 self.mti = (self.mti + 1) % 624 return _int32(y) def twist(self): for i in range(0, 624): y = _int32((self.mt[i] \u0026amp; 0x80000000) + (self.mt[(i + 1) % 624] \u0026amp; 0x7fffffff)) self.mt[i] = (y \u0026gt;\u0026gt; 1) ^ self.mt[(i + 397) % 624] if y % 2 != 0: self.mt[i] = self.mt[i] ^ 0x9908b0df 根据代码分析过程。因为社区已经有人讲过很详细的过程，我们这里就只说一下大致分为三个过程\n初始化 根据种子seed，生成初始状态mt(共有624个数据。然后mti==0.\n处理mt生成随机数 对mt进行一系列线性操作然后生成随机数。\n进行旋转 当已经生成了624个随机数时，相当于耗光了一轮的状态。就需要利用旋转生成新一轮数据，观察这个twist代码，我们可以利用这个预测624位之后出现的下一轮的mt状态然后预测下一个随机数。\n1 2 3 4 5 6 7 8 9 10 11 M1=[] M2=[] rng=MT19937(seed=1123) for i in range(1248): a=rng.extract_number() if i\u0026lt;624: M1.append(a) else: M2.append(a) print(M1) print(M2) 如图可以调用函数生成随机数我们可以利用M1预测M2的数据。\n我们可以用RandCrack库预测生成的随机数和生成之前生成的随机数，也可以自己写一个预测的代码。\n库函数 1 2 3 4 5 rc=RandCrack() for i in M1: rc.submit(i) next=rc.predict_randrange(0, 0xFFFFFFFF)#(这里确定输出的起始和末尾bit,，这里在后面讲解为何这样) print(next) 逆向函数进行预测 逆向extract_number()函数 ​ y = y ^ y \u0026raquo; 11 ​ y = y ^ y \u0026laquo; 7 \u0026amp; 2636928640 ​ y = y ^ y \u0026laquo; 15 \u0026amp; 4022730752 ​ y = y ^ y \u0026raquo; 18\n这是这个函数最关键的部分，我们在一轮中可以利用生成一轮的随机数恢复mt，然后预测下一轮的mt恢复数据，从下往上。\n我们把操作后的y写成bit形式y=$y_1..y_{32}$ |同时记操作前$x=x_1..x_{32}$。。。\n​ $$y=x\\oplus x\u003e\u003en$$ n\u0026gt;=32-n\n那么有$y_1..y_{32}=x_1..x_{32}\\oplus 0..0x_1..x_{32-n}$\n那么$y_1..y_n=x_1..x_n$ $x_{n+1}..x_{32}\\oplus x_1..x_{32-n}=y_{n+1}..y_{32}$\n可以得到$x_{n+1}..x_{32}=y_{n+1}..y_{32}\\oplus y_1..y_{32-n}$ 因为n\u0026gt;32-n,所以$y_1..y_{32-n}$是已知的\n所以$x=y\u0026raquo;n$\n同理，当n\u0026lt;32-n ,情况有所转变\n最后这里无法$y_{n+1}..y_{32}\\oplus y_1..y_{32-n}$ 无法一次性完全恢复多轮几次就好了。\n我们可以$x_{n+1}..x_{2n+1}=y_{n+1}..y_{32}\\oplus y_1..y_{n+1}$\n我们多进行几次这样的变化就行了。\n逆向代码\n1 2 3 4 5 6 7 8 9 10 def re_right(self,x,bit,mask=0xffffffff): tmp=x for _ in range(32//bit): tmp=x^tmp\u0026gt;\u0026gt;bit\u0026amp;mask return tmp def re_left(self,x,bit,mask=0xffffffff): tmp=x for _ in range(32//bit): tmp=x^tmp\u0026lt;\u0026lt;bit\u0026amp;mask return tmp 这里如果我们只进行正向的预测，就暂时不用反向写一个twist代码了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def re_extract(self,m): m=self.re_right(m,18,0xffffffff) m=self.re_left(m,15,4022730752) m=self.re_left(m,7,2636928640) m=self.re_right(m,11) return m\u0026amp;0xffffffff def re_state(self,outputs): if len(outputs)!=624: raise ValueError(\u0026#34;Invalid number of outputs\u0026#34;) self.mt=[self.re_extract(m)for m in outputs] self.mti=0 return self.mt M1=[] M2=[] rng=MT19937(seed=1123) for i in range(1248): a=rng.extract_number() if i\u0026lt;624: M1.append(a) else: M2.append(a) print(M1) print(M2) pre=MT19937() pre.re_state(M1) print(\u0026#34;预测 RNG:\u0026#34;, [pre.extract_number() for _ in range(10)]) 结合上述代码可以很好的预测下一个。不过我们要如果进行恢复前面的数和更精简的操作。便需要逆向twist\n1 2 3 4 5 6 7 def twist(self): for i in range(0, 624): y = _int32((self.mt[i] \u0026amp; 0x80000000) + (self.mt[(i + 1) % 624] \u0026amp; 0x7fffffff)) self.mt[i] = (y \u0026gt;\u0026gt; 1) ^ self.mt[(i + 397) % 624] if y % 2 != 0: self.mt[i] = self.mt[i] ^ 0x9908b0df 第一版函数代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def re_twist(self,mt): re_tw=[0]*624#生成列表 a=deepcopy(mt[623]) c=deepcopy(mt[396]) for i in range(623,-1,-1):#从大到小遍历，以便twist[(i+397)%624]是符合条件的 k=mt[i]^mt[(i+397) % 624] if (k\u0026amp;0x80000000)\u0026gt;\u0026gt;31==1:#判断y\u0026gt;\u0026gt;1的第一位 k=k^0x9908b0df low=1 high=(k\u0026amp;0x40000000)\u0026gt;\u0026gt;30 re_tw[i]=high\u0026lt;\u0026lt;31 re_tw[(i+1)%624]=re_tw[(i+1)%624]+((k\u0026amp;0x3fffffff)\u0026lt;\u0026lt;1)+low if i !=623: mt[(i+1)%624]=re_tw[(i+1)%624]#还原正确的依赖 elif (k \u0026amp; 0x80000000) \u0026gt;\u0026gt; 31 == 0: low = 0 high = (k \u0026amp; 0x40000000) \u0026gt;\u0026gt; 30 re_tw[i] = high \u0026lt;\u0026lt; 31 re_tw[(i + 1) % 624] = re_tw[(i + 1) % 624] + ((k \u0026amp; 0x3fffffff) \u0026lt;\u0026lt; 1) + low if i != 623: mt[(i + 1) % 624] = re_tw[(i + 1) % 624] return re_tw 这个反转函数，可读性不太好，我们从大到小遍历。\n先将异或mt[(i+397) % 624] (从大到小的很明显的是能够直接利用这个反解，并且每一次循环后都会更改依赖)\n不过这关有个缺陷就是不能还原出mt[0]，\n因为最后一个计算mt[0]的时候会自动把re_tw[0]变成re_tw[i]=high\u0026laquo;31。\n我恢复出来结果恢复出了它下一个的mt1[0]所以最后我换了一个方法。\n比如我们要求mt[i],已知它旋转后mt1[]\n我们利用mt1[i]恢复出mt[i]的最高的1位，然后再利用mt1[i-1]恢复出第的31位\n具体恢复过程\n1 2 0x7fffffff=0b01111111111111111111111111111111 0x80000000=0b10000000000000000000000000000000 如果这种操作应用给一个规定的32bit的数那么\n1 y = _int32((self.mt[i] \u0026amp; 0x80000000) + (self.mt[(i + 1) % 624] \u0026amp; 0x7fffffff)) 在y等于mt[i]第32Bit 和.mt[(i + 1) % 624]的后31bit之和\n由于都是线性操作，我们先\nk=mt[i]^mt[(i+397) % 624]，\n如果k与0x9908b0df异或过，那么由于(y\u0026laquo;1)^0x9908b0df=k， k\u0026laquo;31==1。\n如果k没与0x9908b0df异或 k\u0026laquo;31==0\n便能通过y得到我们想要的信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def re_tw1(mt):\thigh=0x80000000 low=0x7fffffff mask=0x9908b0df for i in range(623,-1,-1): t=mt[i]^mt[(i+397) % 624] if t\u0026amp;high==high: t=t^mask t=t\u0026lt;\u0026lt;1 t|=1#确定位奇数 else: t=t\u0026lt;\u0026lt;1 res=t\u0026amp;high #取得高位 t=mt[i-1]^mt[(i+396) % 624] if t\u0026amp;high==high: t=t^mask t=t\u0026lt;\u0026lt;1 t|=1 else: t=t\u0026lt;\u0026lt;1 res=res+(t\u0026amp;low) mt[i]=res return mt 验证代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if __name__ == \u0026#39;__main__\u0026#39;: M1 = [] M2 = [] rng = MT19937(seed=1123) for i in range(1248): a = rng.extract_number() if i \u0026lt; 624: M1.append(a) else: M2.append(a) print(f\u0026#39;M1={M1}\u0026#39;) print(f\u0026#39;M2={M2}\u0026#39;) pre = MT19937() m = pre.re_state(M2) pre.mt=re_tw1(m) print(pre.mt) print(\u0026#34;预测 RNG:\u0026#34;, [pre.extract_number(x=1) for _ in range(10)]) 可以跑一下是一样的\n这里的x=1是控制是否旋转的，具体翻阅上述源代码。\n[TM19973/MT.py at main · rockfox0/TM19973]\u0026mdash;这是MT19973的源码和逆向的代码的github链接\n如果是不连续的输出信息\r在一些比较难的梅森旋转的题目中，我们得到的随机数是间断，来自于不同的bit值。在正常情况下，我们如果知道了连续的19937个bit的信息(也就是一轮)，我们恢复之前的和预测之后的是很轻易的。\n因为梅森旋转是线性操作，我们可以利用线性代数的知识来做这个。\n假设已知的数据是b，b可以转化为一个向量。y表示初始的state。y经过M这个矩阵的线性运算可以得到b。\n$ yM=b\u0026mdash;y=b(M)^{-1}$\n我们只需要构造出M表示线性运算的过程。\n举个例子。。在python 代码\n1 a=getrandombits(t) 如果t\u0026lt;32，就会先生成正常的一组32bit数，然后把32bit右移16bit。就能得到16bit以内的a。如果我们得到的是一些t=20bit的数据想要恢复它，显然用前面直接逆向的方式是不太可行的。我们这是就可以构造矩阵M，利用线性代数的运算表示线性的运算过程。\n我们要先自定义一个随机数生成器的函数，来表示我们生成随机数的方式。 1 2 3 4 5 def getRows(rng): row=[] for i in range(n): row+=list(map(int, (bin(rng.getrandbits(20))[2:].zfill(20)))) return row 这里表示就是生成20bit内的随机数然后累加1000个到row上得到的row就是一个有20000个0/1数据的列表\n其实我们要求19968Bit的已知数据就够了，不过这里多点也行。\n然后就是构建M线性运算的矩阵,M将初始矩阵变成 1 2 3 4 5 6 7 8 for i in tqdm(range(19968)): state = [0]*624 temp = \u0026#34;0\u0026#34;*i + \u0026#34;1\u0026#34;*1 + \u0026#34;0\u0026#34;*(19968-1-i) for j in range(624): state[j] = int(temp[32*j:32*j+32],2) rng.setstate((3,tuple(state+[624]),None)) M.append(getRows(rng)) M=Matrix(GF(2),M) 这个生成M线性运算的矩阵代码是不变的可以直接。无论生成随机数是隐藏了哪些部分，这些代码都是不变的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from Crypto.Util.number import * from random import * from tqdm import * n=1000 D=[]#1000个得到20 rng=Random() def getRows(rng): row=[] for i in range(n): row+=list(map(int, (bin(rng.getrandbits(20))[2:].zfill(20)))) return row M=[] for i in tqdm(range(19968)): state = [0]*624 temp = \u0026#34;0\u0026#34;*i + \u0026#34;1\u0026#34;*1 + \u0026#34;0\u0026#34;*(19968-1-i) for j in range(624): state[j] = int(temp[32*j:32*j+32],2) rng.setstate((3,tuple(state+[624]),None)) M.append(getRows(rng)) M=Matrix(GF(2),M) print(\u0026#34;行数:\u0026#34;, M.nrows()) print(\u0026#34;列数:\u0026#34;, M.ncols()) r=[] for i in range(n): r+=list(map(int, (bin(D[i])[2:].zfill(20)))) r=vector(GF(2),r) y=M.solve_left(r) G=[] for i in range(624): C=0 for j in range(32): C\u0026lt;\u0026lt;=1 C|=int(y[32*i+j]) G.append(C)#将恢复的state转化为每个元素32bit的列表 import random RNG1 = random.Random() for i in range(624): G[i]=int(G[i]) RNG1.setstate((int(3),tuple(G+[int(624)]),None))#将state作为随机数生成器的初始状态，测试生成的state是否正确 P=[RNG1.getrandbits(20) for _ in range(75)] print(P) print(D[:75]) 知道这两个就比较容易了剩下可以看注释\nps: 多数人的sagemath应该是装在wsl等其他虚拟环境平台上的，因为这个题目比较消耗内存，wsl的内存默认只给6.5G。这个已知20bit的还好，如果未知bit太多消耗内存肯定是不够的。建议把wsl内存上限拉到16G。网上有很多更改教程这里就不说了\ntpctf 2025\r接下来可以看看一道tp的ctf题目\n1 2 3 4 5 6 7 import random with open(\u0026#34;flag.txt\u0026#34;,\u0026#34;rb\u0026#34;) as f: flag=f.read() for i in range(2**64): print(random.getrandbits(32)+flag[random.getrandbits(32)%len(flag)]) input() 这里把最后8bit加上了另一个随机数进行了混淆，不过经过测试，加法可能会影响20bit以上甚至更高。不过在10000bit数据以内大多出现20bit以上数据概率比较小。我们这里设置混淆的是末尾24bit并且是间隔获得信息，获取第一个信息后，后一个随机数就被混淆掉了。我们这里可以获得2700组随机的数据\n构建恢复state的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from Crypto.Util.number import * from random import * from tqdm import * n=2500 D=[] print(len(D)) rng=Random() def getRows(rng): row=[] for i in range(n): row+=list(map(int, (bin(rng.getrandbits(32)\u0026gt;\u0026gt;24)[2:].zfill(8)))) _=rng.getrandbits(32) return row M=[] for i in tqdm(range(19968)): state = [0]*624 temp = \u0026#34;0\u0026#34;*i + \u0026#34;1\u0026#34;*1 + \u0026#34;0\u0026#34;*(19968-1-i) for j in range(624): state[j] = int(temp[32*j:32*j+32],2) rng.setstate((3,tuple(state+[624]),None)) M.append(getRows(rng)) M=Matrix(GF(2),M) print(\u0026#34;行数:\u0026#34;, M.nrows()) print(\u0026#34;列数:\u0026#34;, M.ncols()) r=[] for i in range(n): r+=list(map(int, (bin(D[i]\u0026gt;\u0026gt;24)[2:].zfill(8)))) r=vector(GF(2),r) y=M.solve_left(r) G=[] for i in range(624): C=0 for j in range(32): C\u0026lt;\u0026lt;=1 C|=int(y[32*i+j]) G.append(C)#将恢复的state转化为每个元素32bit的列表 import random RNG1 = random.Random() for i in range(624): G[i]=int(G[i]) RNG1.setstate((int(3),tuple(G+[int(624)]),None))#将state作为随机数生成器的初始状态，测试生成的state是否正确 恢复出状态后我们可以得到未被混淆的随机数。我们先可以利用爆破求出flag的长度和flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 G=[] for i in range(624): G[i]=int(G[i]) RNG1 = Random() RNG1.setstate((int(3),tuple(G+[int(624)]),None)) flag=[] ind=[] for i in range(len(X)): a = RNG1.getrandbits(32) b = RNG1.getrandbits(32) f = X[i]-a if 0 \u0026lt; f \u0026lt; 255 : flag.append(f) ind.append(b) for fl in range(len(set(flag)),50):#fl是flag的长度，利用爆破判断长度是否符合条件 TN = [i%fl for i in ind] TF = [] for i in range(fl): t = TN.index(i) TF.append(flag[t]) TF = bytes(TF) if TF[:6]==(b\u0026#39;TPCTF{\u0026#39;): print(TF) ","date":"2025-05-09T00:00:00Z","permalink":"https://cryptographytrifolium.github.io/p/%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/","title":"梅森旋转生成随机数"},{"content":"正文测试\r而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用\r思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片\r1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://cryptographytrifolium.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://cryptographytrifolium.github.io/p/test-chinese/","title":"Chinese Test"}]